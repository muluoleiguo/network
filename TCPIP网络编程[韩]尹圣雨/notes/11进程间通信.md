进程间通信(Inter Process Communication )意味着两个不同进程间可以交换数据，操作系统中应提供两个进程可以同时访问的内存空间。

**通过管道（PIPE）实现进程间通信**

管道并非属于进程的资源，而是和套接字一样，属于操作系统（也就不是fork函数的复制对象）。

创建管道的函数

```c
#include<unistd.h>
int pipe(int filedes[2]);
//成0败-1
```

filedes[0]通过管道接收数据时使用的文件描述符,即管道出口。

filedes[1]]通过管道传输数据时使用的文件描述符，即管道入口。



以长度为2的int数组地址值作为参数调用述函数时，数组中存有两个文件描述符，它们将被用作管道的出口和人口。父进程调用该函数时将创建管道，同时获取对应于出入口的文件描述符，此时父进程可以读写同一管道。但父进程的目的是与子进程进行数据交换，因此需要将入口或出口中的1个文件描述符传递给子进程（通过调用fork函数）

![image-20210119155654426](C:\Users\55018\AppData\Roaming\Typora\typora-user-images\image-20210119155654426.png)

重点在于，父子进程都可以访问管道的I/O路径，但子进程仅用输入路径，父进程仅用输出路径。



**通过管道进行进程间双向通信**

![image-20210119155741455](C:\Users\55018\AppData\Roaming\Typora\typora-user-images\image-20210119155741455.png)

**向管道传递数据时，先读的进程会把数据取走。**

简言之，数据进入管道后成为无主数据。也就是通过read函数先读取数据的进程将得到数据,即使该进程将数据传到了管道。

**只用1个管道进行双向通信并非易事**



1个管道无法完成双向通信任务， 因此需要创建2个管道， 各自负责不同的数据流动即可。

![image-20210119160549168](C:\Users\55018\AppData\Roaming\Typora\typora-user-images\image-20210119160549168.png)





==**即使开始时只想学习必要部分，最后也会需要掌握所有内容**==