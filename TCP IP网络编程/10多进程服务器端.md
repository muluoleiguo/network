**并发服务器端的实现方法**

网络程序中数据通信时间比CPU运算吋间占比更大

具有代表性的并发服务器端实现模型和方法：

多进程服务器：通过创建多个进程提供服务。
多路复用服务器：通过捆绑并统一管理I/O对象提供服务。
多线程服务器：通过生成与客户端等量的线程提供服务。



1多进程服务器（基于Linux）

**进程（Process）**：占用内存空间的正在运行的程序

“操作系统别是白学了啊”

从操作系统的角度看，进程是程序流的基本单位



1个CPU中可能包含多个运算设备（核）。核的个数与可同时运行的进程数相同。相反，若进程数超过核数，进程将分时使用CPU资源。

**进程ID**

无论进程是如何创建的，所有进程都会从操作系统分配到ID。其值为大于2的整数。1要分配给操作系统启动后的（用于协助操作系统）首个进程，因此用户进程无法得到ID值1。



**通过ps指令**可以查看当前运行的所有进程。特别需要注意的是，该命令同时列出PID （进程ID）。另外，上述示例通过指定a和u参数列出了所有进程详细信息。



**通过调用fork函数创建进程**

```c
#include<unistd.h>
pid_t fork(void);
//成功返回进程ID，失败时返回-1
```

fork函数将创建调用的进程副本，包就是说，并非根据完全不同的程序创建进程.而是复制正在运行的、调用fork函数的进程。

另外，两个进程都将执行fork函数调用后语句（准确地说是在fork函数返回后）。

但因为通过同一个进程、复制相同的内存空间，之后的程序流要根据fork函数的返回值加以区分

**父进程：fork函数返回子进程ID。
子进程：fork函数返回0。**

“父进程” (Parent Process )指原进程，即调用fork函数的主体，而“子进程”(Child Process )是通过父进程调用fork函数复制出的进程。

![image-20210119112942372](C:\Users\55018\AppData\Roaming\Typora\typora-user-images\image-20210119112942372.png)



**僵尸进程**

进程销毁也和进程创建同等重要。进程完成工作后（执行完main函数中的程序后）应被销毁，但有时这些进程将变成僵尸进程.占用系统中的重要资源。



**产生原因**

调用fork函数产生子进程的终止方式。

**传递参数并调用exit函数。**

**main函数中执行return语句并返回值。**

向exit函数传递的参数值和main函数的return语句返回的值都会传递给操作系统。而操作系统不会销毁子进程，直到把这些值传递给产生该子进程的父进程。处在这种状态下的进程就是僵尸进程。也就是说，将子进程变成僵尸进程的正是操作系统。



销毁僵尸进程：应该向创建子进程的父进程传递子进程的exit参数值或return语句的返回值

操作系统不会主动把这些值传递给父进程。只有父进程主动发起请求（函数调用）时，操作系统才会传递该值。换言之，父进程未主动要求获得子进程结束状态值，操作系统将一直保存，并让子进程长时间处于僵尸进程状态。也就是说，父母要责收回自己生的孩子（塞回去？）。



**ps 进程状态为僵尸进程（Z+ ）**



后台处理：将控制台中指令放到后台运行的方式

./zombie &

**&将触发后台处理**

在同一控制台就可以进行其它操作了



**销毁僵尸进程1：利用wait函数**

```c
#include<sys/wait.h>
pid_t wait(int* statloc);
//成功时返回终止的子进程ID，失败时返回-1
```

调用此函数时如果已有子进程终止，那么子进程终止时传递的返回值（exit函数的参数值、main函数的return返冋值）将保存到该函数的参数所指内存空间。但函数参数指向的单元中还包含其他信息，因此需要通过下列宏进行分离。

向wait函数传递变量status的地址时，调用wait函数后应编写如下代码

**WIFEXITED子进程正常终止时返回“真”（true）。
 WEXITSTATUS返回子进程的返回值。**

```c
if(WIFEXITED(status))//是否正常终止
{
    puts("Normal termination!");
    printf("Child pass num: %d", WEXITSTATUS(status)); //返回值是多少？
}
```

**调用wait函数时，如果没有已终止的子进程，那么程序将阻塞（Blocking）直到有子进程终止，因此需谨慎调用该函数。**



**销毁2：使用waitpid函数**

```c
#include<sys/wait.h>
pid_t waitpid(pid_t pid,int* statloc,int options);
//成功返回终止的子进程ID（或0），败-1
```





pid： 等待终止的目标子进程的ID,**若传递-1,则与wait函数相同**，可以等待任意子进程终止。
statloc： 与wait函数的statloc参数具有相同含义。
options ：传递头文件sys/wait.h中声明的常量WNOHANG,即使没有终止的子进程也不会进入阻塞状态，而是返回0并退出函数。



**信号处理**

信号处理(Signal Handling )机制。此处的“信号”是在特定事件发生时由操作系统向进程发送的消息。|

为了响应该消息，执行与消息相关的自定义操作的过程称为“处理”





**JAVA在语言层面支持进程和线程的创建。**





**信号与signal函数**

进程发现自己的子进程结束时，请求操作系统调用特定函数。

信号注册函数：

```c
#include<signal.h>
void (*signal(int signo,void(*fun)(int)))(int);
//为了在产生信号时调用，返回之前注册的函数指针
```

**有些难理解的函数指针**

函数名:signal
参数：int signo, void （* func）（int）
返回类型：参数为int型，返回void型函数指针。



**不要畏惧未知**

调用上述函数时，第一个参数是特殊情况信息，第二个参数为特殊情况下将要调用的函数的地址值（指针）



发生第一个参数代表的情况时，调用第二个参数所指的函数



 SIGALRM：已到通过调用alarm函数注册的时间。
 SIGINT：输人CTRL+C
 SIGCHLD：子进程终止



情景1：子进程终止则调用mychild函数。mychild函数的参数应为int，返回值类型应为void，对应signal函数的第二个参数 void （* func）（int）

常数SIGCHLD定义了子进程终止的情况，是signal第一个参数

`signal(SIGCHLD,mychild);`



情景2：已到通过alarm函数注册的时间，请调用timeout函数。

情景3：输入CTRL+C时调用keycontrol函数

代表这2种情况的常数分别为SIGALRM和SIGINT

`signal(SIGALRM, timeout);
signal(SIGINT, keycontrol);`

```c
void timeout(int sig)   
   {
       if(sig==SIGALRM)    
           puts("Time out!");    
       alarm(2);
  }
   
  void keycontrol(int sig)
 {
     if(sig==SIGINT)
         puts("CTRL+C pressed");
  }
//信号处理函数。这种类型的函数称为信号处理器（Handler）。

```



信号注册完成后，发生注册的情况时，操作系统将调用该信号对应的函数

```c
#include<unistd.h>
unsigned int alarm(unsigned int seconds);
//返回距SIGALRM信号发生所剩时间（秒为单位）
```

如果调用该函数的同吋向它传递一个正整型参数， 相应吋间后（以秒为单位）将产生SIGALRM信号

若向该函数传递0，则之前对SIGALRM信号的预约将取消。

如果通过该函数预约信号后未指定该信号对应的处理函数，则（通过调用signal函数）终止进程，不做任何处理。





**发生信号时将唤醒由于调用sleep函数而进入阻塞状态的进程**

调用函数的主体的确是操作系统，但进程处于睡眠状态时无法调用函数。因此，产生信号时，为了调用信号处理器，**将唤醒由于调用sleep函数而进入阻塞状态的进程**。而且，进程一旦被唤醒，就不会再进人睡眠状态。即使还未到sleep函数中规定的时间也是如此.







**利用sigaction函数进行信号处理**

sigaction函数，它类似于signal函数，而且完全可以代替后者，也更稳定。signal函数在UNIX系列的不同操作系统中可能存在区别，但sigaction完全一致



```c
#include<signal.h>
int sigaction(int signo,const struct sigaction* act,struct sigaction* oldact);
//成功返回0，败-1

struct sigaction
{
    void (*sa_handler)(int);//保存信号处理函数的指针值（地址值）□
    sigset_t sa_mask;
    //指定信号相关的选项和特性.初始化为0即可。调用sigemptyset函数将sa_mask成员的所有位初始化为0。

    int sa_flags;//指定信号相关的选项和特性，赋值初始化为0即可
}
```

signo:与signal函数相同，传递信号信息。
act:对应于第一个参数的信号处理函数（信号处理器）信息。
oldact:通过此参数获取之前注册的信号处理函数指针，若不需要则传递0。

**利用信号处理技术消灭僵尸进程**

子进程终止时将产生SIGCHLD信号，知道后很容易完成。









**基于进程的并发服务器模型**

![image-20210119143153676](C:\Users\55018\AppData\Roaming\Typora\typora-user-images\image-20210119143153676.png)

每当有客户端请求服务（连接请求）时，回声服务器端都创建子进程以提供服务。请求服务的客户端若有5个，则将创建5个子进程提供服务。



第一阶段：回声服务器端（父进程）通过调用accept函数受理连接请求。
第二阶段：此时获取的套接字文件描述符创建并传递给子进程。
第三阶段：子进程利用传递来的文件描述符提供服务。

**子进程会复制父进程拥有的所有资源**

调用fork函数时复制父进程的所有资源，有些人可能认为也会同时复制套接字。但套接字并非进程所有——从严格意义上说，套接字属于操作系统——只是进程拥有代表相应套接字的文件描述符。

**复制套接字后，同一端口将对应多个套接字**



调用fork函数后，2个文件描述符指向同一套接字。

![image-20210119150220354](C:\Users\55018\AppData\Roaming\Typora\typora-user-images\image-20210119150220354.png)

1个套接字中存在2个文件描述符时，只有2个文件描述符都终止（销毁）后，才能销毁套接字。如果维持图中的连接状态，即使子进程销毁了与客户端连接的套接字文件描述符，也无法完全销毁套接字（服务器端套接字同样如此）。因此，调用fork函数后，要将无关的套接字文件描述符关掉

![image-20210119150318088](C:\Users\55018\AppData\Roaming\Typora\typora-user-images\image-20210119150318088.png)



**分割TCP的I/O程序**

客户端中分割I/O程序（Routine）的方法

客户端的父进程负责接收数据，额外创建的子进程负责发送数据。分割后，不同进程分别负责输入和输出

![image-20210119150754559](C:\Users\55018\AppData\Roaming\Typora\typora-user-images\image-20210119150754559.png)

父进程中只需编写接收数据的代码，子进程中只需编写发送数据的代码，所以会简化。实际上，在1个进程内同时实现数据收发逻辑需要考虑更多细节。

![image-20210119150844081](C:\Users\55018\AppData\Roaming\Typora\typora-user-images\image-20210119150844081.png)

分割I/O程序的另一个好处是，可以提高频繁交换数据的程序性能